#include <stdio.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <iphlpapi.h>
#include <tchar.h>
#include <lmcons.h>
#include <windows.h>
#include <lm.h>

#define SM_SERVERR2 89

// Function to get system version information
void getSystemVersion() {
    OSVERSIONINFOEX osvi;
    SYSTEM_INFO si;
    BOOL bOsVersionInfoEx;

    ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    if (!(bOsVersionInfoEx = GetVersionEx((OSVERSIONINFO*)&osvi))) {
        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (!GetVersionEx((OSVERSIONINFO *)&osvi))
            return;
    }

    GetSystemInfo(&si);

    printf("System Version: %d.%d\n", osvi.dwMajorVersion, osvi.dwMinorVersion);
    printf("Build Number: %d\n", osvi.dwBuildNumber);
    printf("Platform: %d\n", osvi.dwPlatformId);

    if (osvi.dwMajorVersion == 6 && osvi.dwMinorVersion == 2) {
        if (GetSystemMetrics(SM_SERVERR2))
            printf("Windows Server 2012 R2\n");
        else if (osvi.wProductType == VER_NT_WORKSTATION && si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_ARM)
            printf("Windows RT 8.1\n");
        else
            printf("Windows 8.1\n");
    }
    // Add other version checks here
}

// Function to get the current username
void getUserName() {
    TCHAR userName[UNLEN + 1]; // UNLEN is a constant representing the maximum length of a username
    DWORD size = UNLEN + 1;
    
    if (GetUserName(userName, &size)) {
        _tprintf(_T("Username: %s\n"), userName);
    } else {
        _tprintf(_T("Failed to get the username.\n"));
    }
}

// Function to get the current directory
void getCurrentDirectory() {
    TCHAR currentDirectory[MAX_PATH];

    if (GetCurrentDirectory(MAX_PATH, currentDirectory) > 0) {
        _tprintf(_T("Current Directory: %s\n"), currentDirectory);
    } else {
        _tprintf(_T("Failed to get the current directory.\n"));
    }
}

// Function to get information about the current process
void getProcessInfo() {
    DWORD processId = GetCurrentProcessId();
    TCHAR processPath[MAX_PATH];

    if (GetModuleFileName(NULL, processPath, MAX_PATH)) {
        _tprintf(_T("Current Process ID: %u\n"), processId);
        _tprintf(_T("Current Process Path: %s\n"), processPath);
    } else {
        _tprintf(_T("Failed to get information about the current process.\n"));
    }
}

// Function to get the host name
void getHostName() {
    TCHAR hostName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD size = MAX_COMPUTERNAME_LENGTH + 1;

    if (GetComputerName(hostName, &size)) {
        _tprintf(_T("Host Name: %s\n"), hostName);
    } else {
        _tprintf(_T("Failed to get the host name.\n"));
    }
}

// Function to get the IPv4 address
void getIPv4() {
    PMIB_IPADDRTABLE pIPAddrTable = NULL;
    DWORD dwSize = 0;
    DWORD dwRetVal = 0;

    // Get the required size of the buffer
    if (GetIpAddrTable(pIPAddrTable, &dwSize, FALSE) == ERROR_INSUFFICIENT_BUFFER) {
        pIPAddrTable = (PMIB_IPADDRTABLE)malloc(dwSize);
        if (pIPAddrTable != NULL) {
            if (GetIpAddrTable(pIPAddrTable, &dwSize, FALSE) == NO_ERROR) {
                DWORD i;
                for (i = 0; i < pIPAddrTable->dwNumEntries; i++) {
                    DWORD ipAddress = pIPAddrTable->table[i].dwAddr;
                    printf("IPv4 Address: %d.%d.%d.%d\n",
                        (ipAddress & 0xFF), (ipAddress >> 8 & 0xFF),
                        (ipAddress >> 16 & 0xFF), (ipAddress >> 24 & 0xFF));
                }
            } else {
                printf("Failed to get IPv4 network information.\n");
            }
            free(pIPAddrTable);
        } else {
            printf("Failed to allocate memory for IPv4 network information.\n");
        }
    } else {
        printf("Failed to get IPv4 network information.\n");
    }
}

// Function to check administrator privileges
void checkAdministratorPrivileges() {
    BOOL bIsAdmin = FALSE;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup;
    
    if (AllocateAndInitializeSid(&NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &AdministratorsGroup)) {
        if (CheckTokenMembership(NULL, AdministratorsGroup, &bIsAdmin) && bIsAdmin) {
            _tprintf(_T("The user has administrator privileges.\n"));
        } else {
            _tprintf(_T("The user does NOT have administrator privileges.\n"));
        }
        FreeSid(AdministratorsGroup);
    } else {
        _tprintf(_T("Failed to check administrator privileges.\n"));
    }
}

// Function to get the MAC address
void getMacAddress() {
    PIP_ADAPTER_INFO pAdapterInfo = NULL;
    DWORD dwBufLen = 0;

    if (GetAdaptersInfo(pAdapterInfo, &dwBufLen) == ERROR_BUFFER_OVERFLOW) {
        pAdapterInfo = (PIP_ADAPTER_INFO)malloc(dwBufLen);
        if (pAdapterInfo) {
            if (GetAdaptersInfo(pAdapterInfo, &dwBufLen) == NO_ERROR) {
                PIP_ADAPTER_INFO pAdapter = pAdapterInfo;
                while (pAdapter) {
                    _tprintf(_T("MAC Address: %02X:%02X:%02X:%02X:%02X:%02X\n"),
                        pAdapter->Address[0], pAdapter->Address[1], pAdapter->Address[2],
                        pAdapter->Address[3], pAdapter->Address[4], pAdapter->Address[5]);
                    pAdapter = pAdapter->Next;
                }
            } else {
                _tprintf(_T("Failed to get MAC address information.\n"));
            }
            free(pAdapterInfo);
        } else {
            _tprintf(_T("Failed to allocate memory for MAC address information.\n"));
        }
    } else {
        _tprintf(_T("Failed to get MAC address information.\n"));
    }
}

// Function to get the IPv6 address
void getIPv6() {
    WSADATA wsaData;
    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
        _tprintf(_T("Failed to initialize Winsock.\n"));
        return;
    }

    struct addrinfo* result = NULL;
    struct addrinfo* ptr = NULL;
    struct addrinfo hints;

    ZeroMemory(&hints, sizeof(hints));
    hints.ai_family = AF_INET6;

    int iResult = getaddrinfo(NULL, NULL, &hints, &result);
    if (iResult != 0) {
        _tprintf(_T("Failed to get IPv6 network information: %s\n"), gai_strerror(iResult));
        WSACleanup();
        return;
    }

    for (ptr = result; ptr != NULL; ptr = ptr->ai_next) {
        if (ptr->ai_family == AF_INET6) {
            struct sockaddr_in6* sockaddr6 = (struct sockaddr_in6*)ptr->ai_addr;
            char ipAddress[INET6_ADDRSTRLEN];

            if (inet_ntop(AF_INET6, &(sockaddr6->sin6_addr), ipAddress, INET6_ADDRSTRLEN)) {
                _tprintf(_T("IPv6 Address: %S\n"), ipAddress);
            }
        }
    }

    freeaddrinfo(result);
    WSACleanup();
}

// Function to check the status of the Windows Firewall
void checkFirewallStatus() {
    DWORD currentState;
    if (WindowsFirewallIsOn(&currentState)) {
        if (currentState == 0) {
            _tprintf(_T("Windows Firewall is turned off.\n"));
        } else {
            _tprintf(_T("Windows Firewall is turned on.\n"));
        }
    } else {
        _tprintf(_T("Failed to check the status of the Windows Firewall.\n"));
    }
}

// Function to check if the Windows Firewall is turned on
BOOL WindowsFirewallIsOn(DWORD *pfwEnabled) {
    HKEY hPolicyKey;
    LONG lResult;

    // Try to open the Registry key related to Windows Firewall
    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\StandardProfile"), 0, KEY_READ, &hPolicyKey);
    if (lResult != ERROR_SUCCESS) {
        return FALSE;
    }

    DWORD data; // Create a DWORD variable to store the firewall status

    // Try to get the EnableFirewall value indicating whether the firewall is on
    DWORD dataSize = sizeof(data);
    lResult = RegQueryValueEx(hPolicyKey, _T("EnableFirewall"), NULL, NULL, (LPBYTE)&data, &dataSize);
    RegCloseKey(hPolicyKey);

    if (lResult != ERROR_SUCCESS) {
        return FALSE;
    }

    *pfwEnabled = data; // Store the value in the provided pointer
    return TRUE;
}

// Function to get CPU information
void getCPUInfo() {
    SYSTEM_INFO sysInfo;
    GetSystemInfo(&sysInfo);

    _tprintf(_T("CPU Information:\n"));
    _tprintf(_T("Processor Type: %d\n"), sysInfo.wProcessorArchitecture);
    _tprintf(_T("Number of Processors: %d\n"), sysInfo.dwNumberOfProcessors);
    _tprintf(_T("Page Size: %d bytes\n"), sysInfo.dwPageSize);
}

// Function to get RAM information
void getRAMInfo() {
    MEMORYSTATUS memoryStatus;
    GlobalMemoryStatus(&memoryStatus);

    _tprintf(_T("RAM Information:\n"));
    _tprintf(_T("Total Physical Memory: %lu bytes\n"), memoryStatus.dwTotalPhys);
    _tprintf(_T("Available Physical Memory: %lu bytes\n"), memoryStatus.dwAvailPhys);
    _tprintf(_T("Total Virtual Memory: %lu bytes\n"), memoryStatus.dwTotalVirtual);
    _tprintf(_T("Available Virtual Memory: %lu bytes\n"), memoryStatus.dwAvailVirtual);
}

// Function to get the date of the last Windows update check
void getLastWindowsUpdateCheck() {
    HKEY hKey;
    LONG regResult;

    // Try to open the Registry key to get the date of the last Windows update check
    regResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update\\Results\\Detect"), 0, KEY_READ, &hKey);

    if (regResult == ERROR_SUCCESS) {
        FILETIME lastUpdate;
        DWORD dataSize = sizeof(FILETIME);

        // Try to read the date of the last update check
        regResult = RegQueryValueEx(hKey, _T("LastSuccessTime"), NULL, NULL, (LPBYTE)&lastUpdate, &dataSize);

        if (regResult == ERROR_SUCCESS) {
            SYSTEMTIME sysTime;
            FileTimeToSystemTime(&lastUpdate, &sysTime);

            _tprintf(_T("Last Windows Update Check: %04d/%02d/%02d %02d:%02d:%02d\n"),
                sysTime.wYear, sysTime.wMonth, sysTime.wDay, sysTime.wHour, sysTime.wMinute, sysTime.wSecond);
        } else {
            _tprintf(_T("Failed to get the date of the last Windows update check.\n"));
        }

        RegCloseKey(hKey);
    } else {
        _tprintf(_T("Failed to access the Registry for the date of the last Windows update check.\n"));
    }
}

int main() {
    getSystemVersion();
    getUserName();
    getCurrentDirectory();
    getProcessInfo();
    getHostName();
    getIPv4();
    checkAdministratorPrivileges();
    getMacAddress();
    getIPv6();
    checkFirewallStatus();
    getCPUInfo();
    getRAMInfo();
    getLastWindowsUpdateCheck();
    return 0;
}
